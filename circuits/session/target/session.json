{"noir_version":"1.0.0-beta.2+1a2a08cbcb68646ff1aaef383cfc1798933c1355","hash":12199894975786827341,"abi":{"parameters":[{"name":"operation","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"start_time","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"slot_id","type":{"kind":"array","length":16,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"vehicle_id","type":{"kind":"array","length":16,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"owner_id","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"price_per_minute","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"deposit_amount","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"end_time","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"original_end_time","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"new_end_time","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"dispute_reason","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"dispute_timestamp","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"evidence_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"session_commitment","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"public_price","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"},{"name":"public_deposit","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"},{"name":"total_charge","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"},{"name":"session_id","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"deposit_refund","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"},{"name":"original_session_id","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"new_session_id","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"additional_charge","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"},{"name":"dispute_id","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"disputed_amount","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"},{"name":"public_dispute_timestamp","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"}],"return_type":null,"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"19":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"27":{"source":"use crate::runtime::is_unconstrained;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE: u32 = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR: u32 = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE: u32 = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR: u32 = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: INT_BLOCK, _state: STATE) -> STATE {}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        /// Safety: the msg_block is checked below in verify_msg_block\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        /// Safety: the msg_block is checked below in verify_msg_block\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    /// Safety: the msg_len is checked below in verify_msg_len\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod tests {\n    use super::{\n        attach_len_to_msg_block, build_msg_block, byte_into_item, get_item_byte, make_item,\n        set_item_byte_then_zeros, set_item_zeros,\n    };\n    use super::INT_BLOCK;\n    use super::sha256_var;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x68, 0x32, 0x57, 0x20, 0xaa, 0xbd, 0x7c, 0x82, 0xf3, 0x0f, 0x55, 0x4b, 0x31, 0x3d,\n            0x05, 0x70, 0xc9, 0x5a, 0xcc, 0xbb, 0x7d, 0xc4, 0xb5, 0xaa, 0xe1, 0x12, 0x04, 0xc0,\n            0x8f, 0xfe, 0x73, 0x2b,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        let result = [\n            91, 122, 146, 93, 52, 109, 133, 148, 171, 61, 156, 70, 189, 238, 153, 7, 222, 184, 94,\n            24, 65, 114, 192, 244, 207, 199, 87, 232, 192, 224, 171, 207,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_multiple_over_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99,\n        ];\n        let result = [\n            116, 90, 151, 31, 78, 22, 138, 180, 211, 189, 69, 76, 227, 200, 155, 29, 59, 123, 154,\n            60, 47, 153, 203, 129, 157, 251, 48, 2, 79, 11, 65, 47,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_just_under_block() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59,\n        ];\n        let result = [\n            143, 140, 76, 173, 222, 123, 102, 68, 70, 149, 207, 43, 39, 61, 34, 79, 216, 252, 213,\n            165, 74, 16, 110, 74, 29, 64, 138, 167, 30, 1, 9, 119,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_not_block_multiple() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116, 61, 117, 115, 45, 97, 115,\n            99, 105, 105, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49,\n            46, 48, 32, 40, 77, 97, 99, 32, 79, 83, 32, 88, 32, 77, 97, 105, 108, 32, 49, 54, 46,\n            48, 32, 92, 40, 51, 55, 51, 49, 46, 53, 48, 48, 46, 50, 51, 49, 92, 41, 41, 13, 10, 115,\n            117, 98, 106, 101, 99, 116, 58, 72, 101, 108, 108, 111, 13, 10, 109, 101, 115, 115, 97,\n            103, 101, 45, 105, 100, 58, 60, 56, 70, 56, 49, 57, 68, 51, 50, 45, 66, 54, 65, 67, 45,\n            52, 56, 57, 68, 45, 57, 55, 55, 70, 45, 52, 51, 56, 66, 66, 67, 52, 67, 65, 66, 50, 55,\n            64, 109, 101, 46, 99, 111, 109, 62, 13, 10, 100, 97, 116, 101, 58, 83, 97, 116, 44, 32,\n            50, 54, 32, 65, 117, 103, 32, 50, 48, 50, 51, 32, 49, 50, 58, 50, 53, 58, 50, 50, 32,\n            43, 48, 52, 48, 48, 13, 10, 116, 111, 58, 122, 107, 101, 119, 116, 101, 115, 116, 64,\n            103, 109, 97, 105, 108, 46, 99, 111, 109, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103,\n            110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115,\n            104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101,\n            108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109,\n            59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 54, 57, 51, 48, 51, 56,\n            51, 51, 55, 59, 32, 98, 104, 61, 55, 120, 81, 77, 68, 117, 111, 86, 86, 85, 52, 109, 48,\n            87, 48, 87, 82, 86, 83, 114, 86, 88, 77, 101, 71, 83, 73, 65, 83, 115, 110, 117, 99, 75,\n            57, 100, 74, 115, 114, 99, 43, 118, 85, 61, 59, 32, 104, 61, 102, 114, 111, 109, 58, 67,\n            111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 105, 109, 101, 45, 86, 101,\n            114, 115, 105, 111, 110, 58, 83, 117, 98, 106, 101, 99, 116, 58, 77, 101, 115, 115, 97,\n            103, 101, 45, 73, 100, 58, 68, 97, 116, 101, 58, 116, 111, 59, 32, 98, 61,\n        ];\n        let result = [\n            112, 144, 73, 182, 208, 98, 9, 238, 54, 229, 61, 145, 222, 17, 72, 62, 148, 222, 186,\n            55, 192, 82, 220, 35, 66, 47, 193, 200, 22, 38, 26, 186,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn msg_big_with_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        let message_size = 297;\n        assert_eq(sha256_var(input, message_size), result);\n    }\n\n    #[test]\n    fn msg_big_no_padding() {\n        let input = [\n            48, 130, 1, 37, 2, 1, 0, 48, 11, 6, 9, 96, 134, 72, 1, 101, 3, 4, 2, 1, 48, 130, 1, 17,\n            48, 37, 2, 1, 1, 4, 32, 176, 223, 31, 133, 108, 84, 158, 102, 70, 11, 165, 175, 196, 12,\n            201, 130, 25, 131, 46, 125, 156, 194, 28, 23, 55, 133, 157, 164, 135, 136, 220, 78, 48,\n            37, 2, 1, 2, 4, 32, 190, 82, 180, 235, 222, 33, 79, 50, 152, 136, 142, 35, 116, 224, 6,\n            242, 156, 141, 128, 248, 10, 61, 98, 86, 248, 45, 207, 210, 90, 232, 175, 38, 48, 37, 2,\n            1, 3, 4, 32, 0, 194, 104, 108, 237, 246, 97, 230, 116, 198, 69, 110, 26, 87, 17, 89,\n            110, 199, 108, 250, 36, 21, 39, 87, 110, 102, 250, 213, 174, 131, 171, 174, 48, 37, 2,\n            1, 11, 4, 32, 136, 155, 87, 144, 111, 15, 152, 127, 85, 25, 154, 81, 20, 58, 51, 75,\n            193, 116, 234, 0, 60, 30, 29, 30, 183, 141, 72, 247, 255, 203, 100, 124, 48, 37, 2, 1,\n            12, 4, 32, 41, 234, 106, 78, 31, 11, 114, 137, 237, 17, 92, 71, 134, 47, 62, 78, 189,\n            233, 201, 214, 53, 4, 47, 189, 201, 133, 6, 121, 34, 131, 64, 142, 48, 37, 2, 1, 13, 4,\n            32, 91, 222, 210, 193, 62, 222, 104, 82, 36, 41, 138, 253, 70, 15, 148, 208, 156, 45,\n            105, 171, 241, 195, 185, 43, 217, 162, 146, 201, 222, 89, 238, 38, 48, 37, 2, 1, 14, 4,\n            32, 76, 123, 216, 13, 51, 227, 72, 245, 59, 193, 238, 166, 103, 49, 23, 164, 171, 188,\n            194, 197, 156, 187, 249, 28, 198, 95, 69, 15, 182, 56, 54, 38,\n        ];\n        let result = [\n            32, 85, 108, 174, 127, 112, 178, 182, 8, 43, 134, 123, 192, 211, 131, 66, 184, 240, 212,\n            181, 240, 180, 106, 195, 24, 117, 54, 129, 19, 10, 250, 53,\n        ];\n        assert_eq(sha256_var(input, input.len() as u64), result);\n    }\n\n    #[test]\n    fn same_msg_len_variable_padding() {\n        let input = [\n            29, 81, 165, 84, 243, 114, 101, 37, 242, 146, 127, 99, 69, 145, 39, 72, 213, 39, 253,\n            179, 218, 37, 217, 201, 172, 93, 198, 50, 249, 70, 15, 30, 162, 112, 187, 40, 140, 9,\n            236, 53, 32, 44, 38, 163, 113, 254, 192, 197, 44, 89, 71, 130, 169, 242, 17, 211, 214,\n            72, 19, 178, 186, 168, 147, 127, 99, 101, 252, 227, 8, 147, 150, 85, 97, 158, 17, 107,\n            218, 244, 82, 113, 247, 91, 208, 214, 60, 244, 87, 137, 173, 201, 130, 18, 66, 56, 198,\n            149, 207, 189, 175, 120, 123, 224, 177, 167, 251, 159, 143, 110, 68, 183, 189, 70, 126,\n            32, 35, 164, 44, 30, 44, 12, 65, 18, 62, 239, 242, 2, 248, 104, 2, 178, 64, 28, 126, 36,\n            137, 24, 14, 116, 91, 98, 90, 159, 218, 102, 45, 11, 110, 223, 245, 184, 52, 99, 59,\n            245, 136, 175, 3, 72, 164, 146, 145, 116, 22, 66, 24, 49, 193, 121, 3, 60, 37, 41, 97,\n            3, 190, 66, 195, 225, 63, 46, 3, 118, 4, 208, 15, 1, 40, 254, 235, 151, 123, 70, 180,\n            170, 44, 172, 90, 4, 254, 53, 239, 116, 246, 67, 56, 129, 61, 22, 169, 213, 65, 27, 216,\n            116, 162, 239, 214, 207, 126, 177, 20, 100, 25, 48, 143, 84, 215, 70, 197, 53, 65, 70,\n            86, 172, 61, 62, 9, 212, 167, 169, 133, 41, 126, 213, 196, 33, 192, 238, 0, 63, 246,\n            215, 58, 128, 110, 101, 92, 3, 170, 214, 130, 149, 52, 81, 125, 118, 233, 3, 118, 193,\n            104, 207, 120, 115, 77, 253, 191, 122, 0, 107, 164, 207, 113, 81, 169, 36, 201, 228, 74,\n            134, 131, 218, 178, 35, 30, 216, 101, 2, 103, 174, 87, 95, 50, 50, 215, 157, 5, 210,\n            188, 54, 211, 78, 45, 199, 96, 121, 241, 241, 176, 226, 194, 134, 130, 89, 217, 210,\n            186, 32, 140, 39, 91, 103, 212, 26, 87, 32, 72, 144, 228, 230, 117, 99, 188, 50, 15, 69,\n            79, 179, 50, 12, 106, 86, 218, 101, 73, 142, 243, 29, 250, 122, 228, 233, 29, 255, 22,\n            121, 114, 125, 103, 41, 250, 241, 179, 126, 158, 198, 116, 209, 65, 94, 98, 228, 175,\n            169, 96, 3, 9, 233, 133, 214, 55, 161, 164, 103, 80, 85, 24, 186, 64, 167, 92, 131, 53,\n            101, 202, 47, 25, 104, 118, 155, 14, 12, 12, 25, 116, 45, 221, 249, 28, 246, 212, 200,\n            157, 167, 169, 56, 197, 181, 4, 245, 146, 1, 140, 234, 191, 212, 228, 125, 87, 81, 86,\n            119, 30, 63, 129, 143, 32, 96,\n        ];\n\n        // Prepare inputs of different lengths\n        let mut input_511 = [0; 511];\n        let mut input_512 = [0; 512]; // Next block\n        let mut input_575 = [0; 575];\n        let mut input_576 = [0; 576]; // Next block\n        for i in 0..input.len() {\n            input_511[i] = input[i];\n            input_512[i] = input[i];\n            input_575[i] = input[i];\n            input_576[i] = input[i];\n        }\n\n        // Compute hashes of all inputs (with same message length)\n        let fixed_length_hash = super::sha256(input);\n        let var_full_length_hash = sha256_var(input, input.len() as u64);\n        let var_length_hash_511 = sha256_var(input_511, input.len() as u64);\n        let var_length_hash_512 = sha256_var(input_512, input.len() as u64);\n        let var_length_hash_575 = sha256_var(input_575, input.len() as u64);\n        let var_length_hash_576 = sha256_var(input_576, input.len() as u64);\n\n        // All of the above should have produced the same hash\n        assert_eq(var_full_length_hash, fixed_length_hash);\n        assert_eq(var_length_hash_511, fixed_length_hash);\n        assert_eq(var_length_hash_512, fixed_length_hash);\n        assert_eq(var_length_hash_575, fixed_length_hash);\n        assert_eq(var_length_hash_576, fixed_length_hash);\n    }\n\n    #[test]\n    fn test_get_item_byte() {\n        let fld = make_item(10, 20, 30, 40);\n        assert_eq(fld, 0x0a141e28);\n        assert_eq(get_item_byte(fld, 0), 10);\n        assert_eq(get_item_byte(fld, 4), 10);\n        assert_eq(get_item_byte(fld, 6), 30);\n    }\n\n    #[test]\n    fn test_byte_into_item() {\n        let fld = make_item(0, 20, 0, 0);\n        assert_eq(byte_into_item(20, 1), fld);\n        assert_eq(byte_into_item(20, 5), fld);\n    }\n\n    #[test]\n    fn test_set_item_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 0, 0, 0);\n        assert_eq(set_item_zeros(fld0, 3), fld1);\n        assert_eq(set_item_zeros(fld0, 4), 0);\n        assert_eq(set_item_zeros(0, 4), 0);\n    }\n\n    #[test]\n    fn test_set_item_byte_then_zeros() {\n        let fld0 = make_item(10, 20, 30, 40);\n        let fld1 = make_item(10, 50, 0, 0);\n        assert_eq(set_item_byte_then_zeros(fld0, 1, 50), fld1);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_0() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48,\n        ];\n        assert_eq(input.len(), 22);\n\n        /// Safety: testing context\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 0) };\n        assert_eq(msg_byte_ptr, input.len());\n        assert_eq(msg_block[0], make_item(input[0], input[1], input[2], input[3]));\n        assert_eq(msg_block[1], make_item(input[4], input[5], input[6], input[7]));\n        assert_eq(msg_block[5], make_item(input[20], input[21], 0, 0));\n        assert_eq(msg_block[6], 0);\n    }\n\n    #[test]\n    fn test_build_msg_block_start_1() {\n        let input = [\n            102, 114, 111, 109, 58, 114, 117, 110, 110, 105, 101, 114, 46, 108, 101, 97, 103, 117,\n            101, 115, 46, 48, 106, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 99,\n            111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 116, 101, 120, 116, 47, 112,\n            108, 97, 105, 110, 59, 32, 99, 104, 97, 114, 115, 101, 116,\n        ];\n        assert_eq(input.len(), 68);\n        /// Safety: test context\n        let (msg_block, msg_byte_ptr) = unsafe { build_msg_block(input, input.len(), 64) };\n        assert_eq(msg_byte_ptr, 4);\n        assert_eq(msg_block[0], make_item(input[64], input[65], input[66], input[67]));\n        assert_eq(msg_block[1], 0);\n    }\n\n    #[test]\n    fn test_attach_len_to_msg_block() {\n        let input: INT_BLOCK = [\n            2152555847, 1397309779, 1936618851, 1262052426, 1936876331, 1985297723, 543702374,\n            1919905082, 1131376244, 1701737517, 1417244773, 978151789, 1697470053, 1920166255,\n            1849316213, 1651139939,\n        ];\n        /// Safety: testing context\n        let msg_block = unsafe { attach_len_to_msg_block(input, 1, 448) };\n        assert_eq(msg_block[0], ((1 << 7) as u32) * 256 * 256 * 256);\n        assert_eq(msg_block[1], 0);\n        assert_eq(msg_block[15], 3584);\n    }\n}\n","path":"std/hash/sha256.nr"},"62":{"source":"use dep::std::hash::sha256;\n\nglobal MAX_SESSION_DURATION: u64 = 24 * 60 * 60;\nglobal MAX_PRICE_PER_MINUTE: u64 = 10_000;\n\nglobal OPERATION_START: u8 = 1;\nglobal OPERATION_END: u8 = 2;\nglobal OPERATION_EXTEND: u8 = 3;\nglobal OPERATION_DISPUTE: u8 = 4;\n\nfn main(\n    operation: u8,\n    start_time: u64,\n    slot_id: [u8; 16],\n    vehicle_id: [u8; 16],\n    owner_id: [u8; 32],\n    price_per_minute: u64,\n    \n    deposit_amount: u64,\n    \n    end_time: u64,\n    \n    original_end_time: u64,\n    new_end_time: u64,\n    \n    dispute_reason: u8,\n    dispute_timestamp: u64,\n    evidence_hash: [u8; 32],\n    \n    session_commitment: pub [u8; 32],\n    public_price: pub u64,\n    public_deposit: pub u64,\n    \n    total_charge: pub u64,\n    session_id: pub [u8; 32],\n    deposit_refund: pub u64,\n    \n    original_session_id: pub [u8; 32],\n    new_session_id: pub [u8; 32],\n    additional_charge: pub u64,\n\n    dispute_id: pub [u8; 32],\n    disputed_amount: pub u64,\n    public_dispute_timestamp: pub u64\n) {\n    if operation == OPERATION_START {\n        start_session(\n            start_time,\n            slot_id,\n            vehicle_id,\n            owner_id,\n            price_per_minute,\n            deposit_amount,\n            session_commitment,\n            public_price,\n            public_deposit\n        );\n    } else if operation == OPERATION_END {\n        end_session(\n            start_time,\n            end_time,\n            price_per_minute,\n            slot_id,\n            vehicle_id,\n            owner_id,\n            deposit_amount,\n            total_charge,\n            session_id,\n            deposit_refund\n        );\n    } else if operation == OPERATION_EXTEND {\n        extend_session(\n            start_time,\n            original_end_time,\n            new_end_time,\n            price_per_minute,\n            slot_id,\n            vehicle_id,\n            owner_id,\n            original_session_id,\n            new_session_id,\n            additional_charge\n        );\n    } else if operation == OPERATION_DISPUTE {\n        dispute_session(\n            start_time,\n            end_time,\n            price_per_minute,\n            slot_id,\n            vehicle_id,\n            owner_id,\n            dispute_reason,\n            evidence_hash,\n            session_id,\n            dispute_id,\n            disputed_amount,\n            dispute_timestamp,\n            public_dispute_timestamp\n        );\n    } else {\n        assert(false);\n    }\n}\n\nfn start_session(\n    start_time: u64,\n    slot_id: [u8; 16],\n    vehicle_id: [u8; 16],\n    owner_id: [u8; 32],\n    price_per_minute: u64,\n    deposit_amount: u64,\n\n    session_commitment: [u8; 32],\n    public_price: u64,\n    public_deposit: u64\n) {\n    assert(price_per_minute <= MAX_PRICE_PER_MINUTE);\n    assert(price_per_minute > 0);\n    assert(price_per_minute == public_price);\n    assert(deposit_amount == public_deposit);\n    assert(deposit_amount >= price_per_minute * 60);\n    \n    let mut raw: [u8; 72] = [0; 72];\n    \n    let start_time_bytes = u64_to_le_bytes(start_time);\n    for i in 0..8 {\n        raw[i] = start_time_bytes[i];\n    }\n    for i in 0..16 {\n        raw[8 + i] = slot_id[i];\n    }\n    for i in 0..16 {\n        raw[24 + i] = vehicle_id[i];\n    }\n    for i in 0..32 {\n        raw[40 + i] = owner_id[i];\n    }\n\n    let computed_commitment = sha256(raw);\n    assert(computed_commitment == session_commitment);\n}\n\nfn end_session(\n    start_time: u64,\n    end_time: u64,\n    price_per_minute: u64,\n    slot_id: [u8; 16],\n    vehicle_id: [u8; 16],\n    owner_id: [u8; 32],\n    deposit_amount: u64,\n\n    total_charge: u64,\n    session_id: [u8; 32],\n    deposit_refund: u64\n) {\n    assert(end_time > start_time);\n\n    let duration = end_time - start_time;\n    assert(duration <= MAX_SESSION_DURATION);\n    \n    let minutes = (duration + 59) / 60;\n    let charge = minutes * price_per_minute;\n    assert(charge == total_charge);\n    assert(deposit_amount >= charge);\n    assert(deposit_refund == deposit_amount - charge);\n\n    let mut raw: [u8; 88] = [0; 88];\n    let start_bytes = u64_to_le_bytes(start_time);\n    let end_bytes = u64_to_le_bytes(end_time);\n    let price_bytes = u64_to_le_bytes(price_per_minute);\n    \n    for i in 0..8 {\n        raw[i] = start_bytes[i];\n    }\n    for i in 0..8 {\n        raw[8 + i] = end_bytes[i];\n    }\n    for i in 0..8 {\n        raw[16 + i] = price_bytes[i];\n    }\n    for i in 0..16 {\n        raw[24 + i] = slot_id[i];\n    }\n    for i in 0..16 {\n        raw[40 + i] = vehicle_id[i];\n    }\n    for i in 0..32 {\n        raw[56 + i] = owner_id[i];\n    }\n\n    let computed_session_id = sha256(raw);\n    assert(computed_session_id == session_id);\n}\n\nfn extend_session(\n    original_start_time: u64,\n    original_end_time: u64,\n    new_end_time: u64,\n    price_per_minute: u64,\n    slot_id: [u8; 16],\n    vehicle_id: [u8; 16],\n    owner_id: [u8; 32],\n    \n    original_session_id: [u8; 32],\n    new_session_id: [u8; 32],\n    additional_charge: u64\n) {\n    assert(new_end_time > original_end_time);\n    assert(original_end_time > original_start_time);\n\n    let new_duration = new_end_time - original_start_time;\n    assert(new_duration <= MAX_SESSION_DURATION);\n\n    let mut original_raw: [u8; 88] = [0; 88];\n    let start_bytes = u64_to_le_bytes(original_start_time);\n    let end_bytes = u64_to_le_bytes(original_end_time);\n    let price_bytes = u64_to_le_bytes(price_per_minute);\n    for i in 0..8 {\n        original_raw[i] = start_bytes[i];\n    }\n    for i in 0..8 {\n        original_raw[8 + i] = end_bytes[i];\n    }\n    for i in 0..8 {\n        original_raw[16 + i] = price_bytes[i];\n    }\n    for i in 0..16 {\n        original_raw[24 + i] = slot_id[i];\n    }\n    for i in 0..16 {\n        original_raw[40 + i] = vehicle_id[i];\n    }\n    for i in 0..32 {\n        original_raw[56 + i] = owner_id[i];\n    }\n    let computed_original_id = sha256(original_raw);\n    assert(computed_original_id == original_session_id);\n    let mut new_raw: [u8; 88] = [0; 88];\n    let new_end_bytes = u64_to_le_bytes(new_end_time);\n    \n    for i in 0..8 {\n        new_raw[i] = start_bytes[i];\n    }\n    for i in 0..8 {\n        new_raw[8 + i] = new_end_bytes[i];\n    }\n    for i in 0..8 {\n        new_raw[16 + i] = price_bytes[i];\n    }\n    for i in 0..16 {\n        new_raw[24 + i] = slot_id[i];\n    }\n    for i in 0..16 {\n        new_raw[40 + i] = vehicle_id[i];\n    }\n    for i in 0..32 {\n        new_raw[56 + i] = owner_id[i];\n    }\n    let computed_new_id = sha256(new_raw);\n    assert(computed_new_id == new_session_id);\n\n    let original_duration = original_end_time - original_start_time;\n    let original_minutes = (original_duration + 59) / 60;\n    let new_minutes = (new_duration + 59) / 60;\n    let extra_minutes = new_minutes - original_minutes;\n    let charge = extra_minutes * price_per_minute;\n    assert(charge == additional_charge);\n}\n\nfn dispute_session(\n    start_time: u64,\n    end_time: u64,\n    price_per_minute: u64,\n    slot_id: [u8; 16],\n    vehicle_id: [u8; 16],\n    owner_id: [u8; 32],\n    dispute_reason: u8,\n    evidence_hash: [u8; 32],\n    \n    session_id: [u8; 32],\n    dispute_id: [u8; 32],\n    disputed_amount: u64,\n    dispute_timestamp: u64,\n    public_dispute_timestamp: u64\n) {\n    assert(dispute_reason > 0);\n    assert(dispute_reason <= 5);\n    assert(dispute_timestamp == public_dispute_timestamp);\n    \n    let mut session_raw: [u8; 88] = [0; 88];\n    let start_bytes = u64_to_le_bytes(start_time);\n    let end_bytes = u64_to_le_bytes(end_time);\n    let price_bytes = u64_to_le_bytes(price_per_minute);\n    \n    for i in 0..8 {\n        session_raw[i] = start_bytes[i];\n    }\n    \n    for i in 0..8 {\n        session_raw[8 + i] = end_bytes[i];\n    }\n    \n    for i in 0..8 {\n        session_raw[16 + i] = price_bytes[i];\n    }\n    \n    for i in 0..16 {\n        session_raw[24 + i] = slot_id[i];\n    }\n    \n    for i in 0..16 {\n        session_raw[40 + i] = vehicle_id[i];\n    }\n    \n    for i in 0..32 {\n        session_raw[56 + i] = owner_id[i];\n    }\n    \n    let computed_session_id = sha256(session_raw);\n    assert(computed_session_id == session_id);\n    \n    let duration = end_time - start_time;\n    let minutes = (duration + 59) / 60;\n    let total_charge = minutes * price_per_minute;\n    assert(disputed_amount <= total_charge);\n    \n    let mut dispute_raw: [u8; 128] = [0; 128];\n    \n    for i in 0..88 {\n        dispute_raw[i] = session_raw[i];\n    }\n    \n    dispute_raw[88] = dispute_reason;\n    dispute_raw[89] = 0;\n    dispute_raw[90] = 0;\n    dispute_raw[91] = 0;\n    \n    let timestamp_bytes = u64_to_le_bytes(dispute_timestamp);\n    for i in 0..8 {\n        dispute_raw[92 + i] = timestamp_bytes[i];\n    }\n    for i in 0..32 {\n        dispute_raw[96 + i] = evidence_hash[i];\n    }\n    let computed_dispute_id = sha256(dispute_raw);\n    assert(computed_dispute_id == dispute_id);\n}\n\nfn u64_to_le_bytes(value: u64) -> [u8; 8] {\n    let mut bytes: [u8; 8] = [0; 8];\n    \n    bytes[0] = (value & 0xFF) as u8;\n    bytes[1] = ((value >> 8) & 0xFF) as u8;\n    bytes[2] = ((value >> 16) & 0xFF) as u8;\n    bytes[3] = ((value >> 24) & 0xFF) as u8;\n    bytes[4] = ((value >> 32) & 0xFF) as u8;\n    bytes[5] = ((value >> 40) & 0xFF) as u8;\n    bytes[6] = ((value >> 48) & 0xFF) as u8;\n    bytes[7] = ((value >> 56) & 0xFF) as u8;\n    \n    bytes\n}","path":"/Users/vaibhav/Desktop/noirtest/circuits/session/src/main.nr"}},"names":["main"],"brillig_names":["build_msg_block","attach_len_to_msg_block","build_msg_block","build_msg_block","directive_invert","directive_integer_quotient","directive_to_radix"]}